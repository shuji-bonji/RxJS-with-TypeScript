# マルチキャスティングで利用するオペレーター

RxJSでは、複数の購読者に対して同じObservableの出力を共有する「マルチキャスティング」を実現するために、いくつかの専用オペレーターが用意されています。

このページでは、**演算子としての観点**からマルチキャスティングに関連する代表的なオペレーターを簡単に紹介し、  
その使い分けや注意点について整理します。

> ❗ マルチキャストの概念や Subject を用いた構造的な説明、具体的なコード例については  
> [3. Subjectとマルチキャスト](/guide/subjects/multicasting) の章をご参照ください。

## 主なマルチキャスティング関連オペレーター

| オペレーター | 特徴 | 備考 |
|--------------|------|------|
| `share()` | 最も簡単なマルチキャスト手段。内部で`publish().refCount()`と同等 | 多くのユースケースで十分 |
| `shareReplay()` | マルチキャストに加え、直近の値を再購読時に提供 | 状態の再利用が必要な場合 |
| `publish()` + `refCount()` | 実行タイミングを制御可能なマルチキャスト構成 | 古典的かつ柔軟な構成 |
| `multicast()` | `Subject`を明示的に渡す低レベルAPI | カスタムSubjectを使いたい場合に有効 |

## マルチキャスティングパターンの比較

| オペレーター | 特徴 | ユースケース |
|------------|------|-------------|
| `share()` | 基本的なマルチキャスト | 複数コンポーネントでの同時利用 |
| `shareReplay(n)` | 過去n個の値をバッファ | 遅延購読/状態共有 |
| `publish() + refCount()` | より細かい制御が可能 | 高度な制御が必要な場合 |
| `multicast(() => new Subject())` | 完全なカスタマイズ | 特殊なSubjectタイプが必要な場合 |

## マルチキャスティング使用時の注意点

1. **タイミングの把握**：購読開始時期によって受け取る値が異なることを理解する
2. **ライフサイクル管理**：特に`refCount`を使う場合、購読者がゼロになるとストリームが完了する
3. **エラー処理**：マルチキャストされたObservableでエラーが発生すると、全購読者に影響する
4. **メモリ管理**：`shareReplay`などを使う場合、メモリリークに注意する
