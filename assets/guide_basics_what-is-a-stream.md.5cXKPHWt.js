import{_ as t,c as a,o as r,a2 as i}from"./chunks/framework.BvXV5w7a.js";const u=JSON.parse('{"title":"ストリームとは？","description":"ストリームとは時間の経過とともに発生するデータの流れを指し、RxJSではObservableとして抽象化されます。イベント、非同期処理、ネットワーク通信など様々なデータソースを統一的に扱う概念を解説します。","frontmatter":{"description":"ストリームとは時間の経過とともに発生するデータの流れを指し、RxJSではObservableとして抽象化されます。イベント、非同期処理、ネットワーク通信など様々なデータソースを統一的に扱う概念を解説します。"},"headers":[],"relativePath":"guide/basics/what-is-a-stream.md","filePath":"guide/basics/what-is-a-stream.md"}'),s={name:"guide/basics/what-is-a-stream.md"};function o(l,e,d,b,c,n){return r(),a("div",null,e[0]||(e[0]=[i('<h1 id="ストリームとは" tabindex="-1">ストリームとは？ <a class="header-anchor" href="#ストリームとは" aria-label="Permalink to &quot;ストリームとは？&quot;">​</a></h1><h2 id="ストリームの定義" tabindex="-1">ストリームの定義 <a class="header-anchor" href="#ストリームの定義" aria-label="Permalink to &quot;ストリームの定義&quot;">​</a></h2><p>「ストリーム」とは、<strong>時間の経過とともに順次発生するデータの流れ</strong>を指します。これは、一定の順序で次々に現れるデータの集合体とみなすことができます。</p><h3 id="従来のプログラミングにおける代表的なストリームの例" tabindex="-1">従来のプログラミングにおける代表的なストリームの例 <a class="header-anchor" href="#従来のプログラミングにおける代表的なストリームの例" aria-label="Permalink to &quot;従来のプログラミングにおける代表的なストリームの例&quot;">​</a></h3><ul><li>ファイル読み込みのデータ（例：Node.js の ReadableStream）</li><li>ネットワーク通信（HTTPレスポンスなど）</li><li>ユーザーの入力やイベント（マウス移動、クリック、キーボード入力）</li></ul><h2 id="rxjsにおけるストリーム" tabindex="-1">RxJSにおけるストリーム <a class="header-anchor" href="#rxjsにおけるストリーム" aria-label="Permalink to &quot;RxJSにおけるストリーム&quot;">​</a></h2><p>RxJSでは、こうした時間経過とともに発生するデータを <strong>Observable（オブザーバブル）</strong> を使ってストリームとして扱います。Observableは、非同期データ、同期データ、イベント、時間ベースの処理などをすべて「ストリーム」として抽象化するための仕組みです。</p><h3 id="observableの利点" tabindex="-1">Observableの利点 <a class="header-anchor" href="#observableの利点" aria-label="Permalink to &quot;Observableの利点&quot;">​</a></h3><ul><li>型安全に記述できる（TypeScriptとの親和性）</li><li>宣言的にデータの流れを表現できる</li><li><code>pipe()</code> による操作チェーンが可能</li><li><code>subscribe()</code> により明示的に購読できる</li><li><code>unsubscribe()</code> によりキャンセル可能</li></ul><h2 id="従来のストリームとの比較" tabindex="-1">従来のストリームとの比較 <a class="header-anchor" href="#従来のストリームとの比較" aria-label="Permalink to &quot;従来のストリームとの比較&quot;">​</a></h2><table tabindex="0"><thead><tr><th>特性</th><th>従来のストリーム</th><th>RxJSのObservable</th></tr></thead><tbody><tr><td>対象</td><td>ファイル/ネットワーク等に限定されがち</td><td>任意の非同期/イベント/状態変化</td></tr><tr><td>イベント対応</td><td>イベントリスナーで都度処理</td><td><code>fromEvent</code> でストリーム化</td></tr><tr><td>キャンセル</td><td>方法はまちまち</td><td><code>unsubscribe()</code> で統一管理</td></tr><tr><td>合成/変換</td><td>手続き型コードで個別実装</td><td>演算子（<code>map</code>, <code>filter</code> など）で簡潔に記述</td></tr></tbody></table><h2 id="observer・subscriptionとの関係" tabindex="-1">Observer・Subscriptionとの関係 <a class="header-anchor" href="#observer・subscriptionとの関係" aria-label="Permalink to &quot;Observer・Subscriptionとの関係&quot;">​</a></h2><ul><li><strong>Observable</strong>：データの供給元（ストリームの源）</li><li><strong>Observer</strong>：データの受け取り手（next, error, complete を持つ）</li><li><strong>Subscription</strong>：購読の制御ハンドル（購読・解除・リソース管理）</li></ul><p>ObservableとObserverは、コールバックを通じて接続され、Subscriptionにより制御されます。</p><h2 id="まとめ" tabindex="-1">まとめ <a class="header-anchor" href="#まとめ" aria-label="Permalink to &quot;まとめ&quot;">​</a></h2><p>RxJSの中核である「ストリーム」の概念は、非同期処理を扱う際の強力な武器です。Observableを使うことで、さまざまなデータソースを統一的に扱い、宣言的かつ柔軟にデータフローを記述できます。</p><h2 id="イベント処理との関係" tabindex="-1">イベント処理との関係 <a class="header-anchor" href="#イベント処理との関係" aria-label="Permalink to &quot;イベント処理との関係&quot;">​</a></h2><p>RxJSでは、DOMイベントも <code>fromEvent</code> を使ってストリームとして扱うことができます。<br> 従来のイベントリスナーとの違いを比較することで、ストリームの概念がより明確になります。</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>実際のコードを交えた従来のイベント処理とRxJSの比較は、<a href="/RxJS-with-TypeScript/guide/observables/events.html#従来のイベント処理とrxjsの比較">イベントのストリーム化</a> を参照してください。</p></div>',19)]))}const p=t(s,[["render",o]]);export{u as __pageData,p as default};
