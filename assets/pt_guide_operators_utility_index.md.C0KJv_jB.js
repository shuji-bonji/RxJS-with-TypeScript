import{_ as t,c as o,o as a,a2 as r}from"./chunks/framework.D3KFGq5-.js";const h=JSON.parse('{"title":"Utility Operators","description":"Utility operators são um grupo de operadores auxiliares no RxJS que são responsáveis por controlar efeitos colaterais, processamento de atraso, gerenciamento de inscrição, etc.","frontmatter":{"description":"Utility operators são um grupo de operadores auxiliares no RxJS que são responsáveis por controlar efeitos colaterais, processamento de atraso, gerenciamento de inscrição, etc."},"headers":[],"relativePath":"pt/guide/operators/utility/index.md","filePath":"pt/guide/operators/utility/index.md","lastUpdated":1765529578000}'),d={name:"pt/guide/operators/utility/index.md"};function i(s,e,c,n,l,p){return a(),o("div",null,[...e[0]||(e[0]=[r('<h1 id="utility-operators" tabindex="-1">Utility Operators <a class="header-anchor" href="#utility-operators" aria-label="Permalink to &quot;Utility Operators&quot;">​</a></h1><p>Utility operators no RxJS são um grupo de operadores responsáveis pelo <strong>processamento auxiliar de streams (efeitos colaterais, controle de estado, suporte de UI, etc.)</strong> em vez do propósito principal de conversão ou filtragem de dados.</p><p>Nesta página, os operadores são categorizados por finalidade conforme mostrado abaixo, e uma lista é fornecida para confirmar seu uso básico. Para uso detalhado e exemplos práticos, consulte as respectivas páginas ou <a href="./practical-use-cases">Casos de Uso Práticos</a>.</p><h2 id="lista-de-operadores-por-finalidade" tabindex="-1">Lista de Operadores (por Finalidade) <a class="header-anchor" href="#lista-de-operadores-por-finalidade" aria-label="Permalink to &quot;Lista de Operadores (por Finalidade)&quot;">​</a></h2><h3 id="◾-efeitos-colaterais-e-controle-de-estado" tabindex="-1">◾ Efeitos Colaterais e Controle de Estado <a class="header-anchor" href="#◾-efeitos-colaterais-e-controle-de-estado" aria-label="Permalink to &quot;◾ Efeitos Colaterais e Controle de Estado&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Operador</th><th>Descrição</th><th>Frequentemente Combinado Com</th></tr></thead><tbody><tr><td><a href="./tap">tap</a></td><td>Executa efeitos colaterais sem alterar valores (saída de log, atualizações de UI, etc.)</td><td><code>map</code>, <code>switchMap</code></td></tr><tr><td><a href="./finalize">finalize</a></td><td>Executa processamento de limpeza quando o stream termina</td><td><code>tap</code>, <code>catchError</code></td></tr></tbody></table><h3 id="◾-controle-de-timing-e-atraso" tabindex="-1">◾ Controle de Timing e Atraso <a class="header-anchor" href="#◾-controle-de-timing-e-atraso" aria-label="Permalink to &quot;◾ Controle de Timing e Atraso&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Operador</th><th>Descrição</th><th>Frequentemente Combinado Com</th></tr></thead><tbody><tr><td><a href="./delay">delay</a></td><td>Atrasa a emissão de cada valor por um tempo especificado</td><td><code>tap</code>, <code>concatMap</code></td></tr><tr><td><a href="./timeout">timeout</a></td><td>Gera um erro se a emissão exceder um determinado tempo</td><td><code>catchError</code>, <code>retry</code></td></tr><tr><td><a href="./takeUntil">takeUntil</a></td><td>Encerra a inscrição quando o Observable especificado notifica</td><td><code>interval</code>, <code>fromEvent</code></td></tr></tbody></table><h3 id="◾-valor-inicial-repeticao-conversao-de-array-etc" tabindex="-1">◾ Valor Inicial, Repetição, Conversão de Array, etc. <a class="header-anchor" href="#◾-valor-inicial-repeticao-conversao-de-array-etc" aria-label="Permalink to &quot;◾ Valor Inicial, Repetição, Conversão de Array, etc.&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Operador</th><th>Descrição</th><th>Frequentemente Combinado Com</th></tr></thead><tbody><tr><td><a href="./startWith">startWith</a></td><td>Emite um valor inicial no início do stream</td><td><code>scan</code>, <code>combineLatest</code></td></tr><tr><td><a href="./repeat">repeat</a></td><td>Reinscreve-se no stream inteiro após a conclusão</td><td><code>tap</code>, <code>delay</code></td></tr><tr><td><a href="./retry">retry</a></td><td>Tenta novamente em caso de erro</td><td><code>catchError</code>, <code>switchMap</code></td></tr><tr><td><a href="./toArray">toArray</a></td><td>Emite todos os valores no stream como um único array (na conclusão)</td><td><code>concatMap</code>, <code>take</code></td></tr></tbody></table><h2 id="observacoes" tabindex="-1">Observações <a class="header-anchor" href="#observacoes" aria-label="Permalink to &quot;Observações&quot;">​</a></h2><ul><li>Diferença entre <code>retry</code> e <code>repeat</code>: <ul><li><code>retry</code>: <strong>Tenta novamente em caso de erro</strong></li><li><code>repeat</code>: <strong>Tenta novamente após conclusão bem-sucedida</strong></li></ul></li><li><code>toArray</code> não gera um valor a menos que seja concluído, então é comumente usado com <code>take()</code> e assim por diante.</li></ul>',12)])])}const u=t(d,[["render",i]]);export{h as __pageData,u as default};
