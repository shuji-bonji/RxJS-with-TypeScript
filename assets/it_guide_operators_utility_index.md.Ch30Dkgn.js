import{_ as t,c as o,o as a,a2 as i}from"./chunks/framework.D3KFGq5-.js";const u=JSON.parse(`{"title":"Operatori Utility","description":"Gli operatori utility sono un gruppo di operatori ausiliari in RxJS che sono responsabili del controllo degli effetti collaterali, dell'elaborazione con ritardo, della gestione delle subscription, ecc.","frontmatter":{"description":"Gli operatori utility sono un gruppo di operatori ausiliari in RxJS che sono responsabili del controllo degli effetti collaterali, dell'elaborazione con ritardo, della gestione delle subscription, ecc."},"headers":[],"relativePath":"it/guide/operators/utility/index.md","filePath":"it/guide/operators/utility/index.md","lastUpdated":1765383284000}`),r={name:"it/guide/operators/utility/index.md"};function l(d,e,n,c,s,p){return a(),o("div",null,[...e[0]||(e[0]=[i('<h1 id="operatori-utility" tabindex="-1">Operatori Utility <a class="header-anchor" href="#operatori-utility" aria-label="Permalink to &quot;Operatori Utility&quot;">​</a></h1><p>Gli operatori utility in RxJS sono un gruppo di operatori responsabili dell&#39;<strong>elaborazione ausiliaria degli stream (effetti collaterali, controllo dello stato, supporto UI, ecc.)</strong> piuttosto che dello scopo principale di conversione o filtraggio dei dati.</p><p>In questa pagina, gli operatori sono categorizzati per scopo come mostrato di seguito, e viene fornito un elenco per confermare il loro utilizzo base. Per utilizzo dettagliato ed esempi pratici, fare riferimento alle rispettive pagine o ai <a href="./practical-use-cases">Casi d&#39;Uso Pratici</a>.</p><h2 id="elenco-operatori-per-scopo" tabindex="-1">Elenco Operatori (per Scopo) <a class="header-anchor" href="#elenco-operatori-per-scopo" aria-label="Permalink to &quot;Elenco Operatori (per Scopo)&quot;">​</a></h2><h3 id="◾-effetti-collaterali-e-controllo-stato" tabindex="-1">◾ Effetti Collaterali e Controllo Stato <a class="header-anchor" href="#◾-effetti-collaterali-e-controllo-stato" aria-label="Permalink to &quot;◾ Effetti Collaterali e Controllo Stato&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Operatore</th><th>Descrizione</th><th>Spesso Combinato Con</th></tr></thead><tbody><tr><td><a href="./tap">tap</a></td><td>Esegui effetti collaterali senza modificare i valori (output log, aggiornamenti UI, ecc.)</td><td><code>map</code>, <code>switchMap</code></td></tr><tr><td><a href="./finalize">finalize</a></td><td>Esegui elaborazione di pulizia quando lo stream termina</td><td><code>tap</code>, <code>catchError</code></td></tr></tbody></table><h3 id="◾-controllo-timing-e-ritardo" tabindex="-1">◾ Controllo Timing e Ritardo <a class="header-anchor" href="#◾-controllo-timing-e-ritardo" aria-label="Permalink to &quot;◾ Controllo Timing e Ritardo&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Operatore</th><th>Descrizione</th><th>Spesso Combinato Con</th></tr></thead><tbody><tr><td><a href="./delay">delay</a></td><td>Ritarda l&#39;emissione di ogni valore di un tempo specificato</td><td><code>tap</code>, <code>concatMap</code></td></tr><tr><td><a href="./timeout">timeout</a></td><td>Genera un errore se l&#39;emissione supera un certo tempo</td><td><code>catchError</code>, <code>retry</code></td></tr><tr><td><a href="./takeUntil">takeUntil</a></td><td>Termina la subscription quando l&#39;Observable specificato notifica</td><td><code>interval</code>, <code>fromEvent</code></td></tr></tbody></table><h3 id="◾-valore-iniziale-ripetizione-conversione-array-ecc" tabindex="-1">◾ Valore Iniziale, Ripetizione, Conversione Array, ecc. <a class="header-anchor" href="#◾-valore-iniziale-ripetizione-conversione-array-ecc" aria-label="Permalink to &quot;◾ Valore Iniziale, Ripetizione, Conversione Array, ecc.&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Operatore</th><th>Descrizione</th><th>Spesso Combinato Con</th></tr></thead><tbody><tr><td><a href="./startWith">startWith</a></td><td>Emetti un valore iniziale all&#39;inizio dello stream</td><td><code>scan</code>, <code>combineLatest</code></td></tr><tr><td><a href="./repeat">repeat</a></td><td>Ri-sottoscrivi l&#39;intero stream dopo il completamento</td><td><code>tap</code>, <code>delay</code></td></tr><tr><td><a href="./retry">retry</a></td><td>Ritenta in caso di errore</td><td><code>catchError</code>, <code>switchMap</code></td></tr><tr><td><a href="./toArray">toArray</a></td><td>Emetti tutti i valori nello stream come un singolo array (al completamento)</td><td><code>concatMap</code>, <code>take</code></td></tr></tbody></table><h2 id="note" tabindex="-1">Note <a class="header-anchor" href="#note" aria-label="Permalink to &quot;Note&quot;">​</a></h2><ul><li>Differenza tra <code>retry</code> e <code>repeat</code>: <ul><li><code>retry</code>: <strong>Ritenta in caso di errore</strong></li><li><code>repeat</code>: <strong>Ritenta in caso di completamento con successo</strong></li></ul></li><li><code>toArray</code> non emette un valore a meno che non completi, quindi è comunemente usato con <code>take()</code> e simili.</li></ul>',12)])])}const m=t(r,[["render",l]]);export{u as __pageData,m as default};
