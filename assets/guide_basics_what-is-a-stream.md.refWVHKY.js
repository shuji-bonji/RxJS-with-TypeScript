import{_ as i,C as o,c as l,o as a,a2 as r,b,w as t,a as d,G as n,a3 as c}from"./chunks/framework.D3KFGq5-.js";const B=JSON.parse('{"title":"ストリームとは？","description":"ストリームとは時間の経過とともに発生するデータの流れを指し、RxJSではObservableとして抽象化されます。イベント、非同期処理、ネットワーク通信など様々なデータソースを統一的に扱う概念を解説します。","frontmatter":{"description":"ストリームとは時間の経過とともに発生するデータの流れを指し、RxJSではObservableとして抽象化されます。イベント、非同期処理、ネットワーク通信など様々なデータソースを統一的に扱う概念を解説します。"},"headers":[],"relativePath":"guide/basics/what-is-a-stream.md","filePath":"guide/basics/what-is-a-stream.md","lastUpdated":1762424408000}'),h={name:"guide/basics/what-is-a-stream.md"};function u(E,e,p,A,m,v){const s=o("Mermaid");return a(),l("div",null,[e[1]||(e[1]=r('<h1 id="ストリームとは" tabindex="-1">ストリームとは？ <a class="header-anchor" href="#ストリームとは" aria-label="Permalink to &quot;ストリームとは？&quot;">​</a></h1><h2 id="ストリームの定義" tabindex="-1">ストリームの定義 <a class="header-anchor" href="#ストリームの定義" aria-label="Permalink to &quot;ストリームの定義&quot;">​</a></h2><p>「ストリーム」とは、<strong>時間の経過とともに順次発生するデータの流れ</strong>を指します。これは、一定の順序で次々に現れるデータの集合体とみなすことができます。</p><h3 id="従来のプログラミングにおける代表的なストリームの例" tabindex="-1">従来のプログラミングにおける代表的なストリームの例 <a class="header-anchor" href="#従来のプログラミングにおける代表的なストリームの例" aria-label="Permalink to &quot;従来のプログラミングにおける代表的なストリームの例&quot;">​</a></h3><ul><li>ファイル読み込みのデータ（例：Node.js の ReadableStream）</li><li>ネットワーク通信（HTTPレスポンスなど）</li><li>ユーザーの入力やイベント（マウス移動、クリック、キーボード入力）</li></ul><h2 id="rxjsにおけるストリーム" tabindex="-1">RxJSにおけるストリーム <a class="header-anchor" href="#rxjsにおけるストリーム" aria-label="Permalink to &quot;RxJSにおけるストリーム&quot;">​</a></h2><p>RxJSでは、こうした時間経過とともに発生するデータを <strong>Observable（オブザーバブル）</strong> を使ってストリームとして扱います。Observableは、非同期データ、同期データ、イベント、時間ベースの処理などをすべて「ストリーム」として抽象化するための仕組みです。</p><h3 id="observableの利点" tabindex="-1">Observableの利点 <a class="header-anchor" href="#observableの利点" aria-label="Permalink to &quot;Observableの利点&quot;">​</a></h3><ul><li>型安全に記述できる（TypeScriptとの親和性）</li><li>宣言的にデータの流れを表現できる</li><li><code>pipe()</code> による操作チェーンが可能</li><li><code>subscribe()</code> により明示的に購読できる</li><li><code>unsubscribe()</code> によりキャンセル可能</li></ul><h2 id="従来のストリームとの比較" tabindex="-1">従来のストリームとの比較 <a class="header-anchor" href="#従来のストリームとの比較" aria-label="Permalink to &quot;従来のストリームとの比較&quot;">​</a></h2><table tabindex="0"><thead><tr><th>特性</th><th>従来のストリーム</th><th>RxJSのObservable</th></tr></thead><tbody><tr><td>対象</td><td>ファイル/ネットワーク等に限定されがち</td><td>任意の非同期/イベント/状態変化</td></tr><tr><td>イベント対応</td><td>イベントリスナーで都度処理</td><td><code>fromEvent</code> でストリーム化</td></tr><tr><td>キャンセル</td><td>方法はまちまち</td><td><code>unsubscribe()</code> で統一管理</td></tr><tr><td>合成/変換</td><td>手続き型コードで個別実装</td><td>演算子（<code>map</code>, <code>filter</code> など）で簡潔に記述</td></tr></tbody></table><h2 id="observer・subscriptionとの関係" tabindex="-1">Observer・Subscriptionとの関係 <a class="header-anchor" href="#observer・subscriptionとの関係" aria-label="Permalink to &quot;Observer・Subscriptionとの関係&quot;">​</a></h2><ul><li><strong>Observable</strong>：データの供給元（ストリームの源）</li><li><strong>Observer</strong>：データの受け取り手（next, error, complete を持つ）</li><li><strong>Subscription</strong>：購読の制御ハンドル（購読・解除・リソース管理）</li></ul><p>ObservableとObserverは、コールバックを通じて接続され、Subscriptionにより制御されます。</p><h3 id="基本的な関係図" tabindex="-1">基本的な関係図 <a class="header-anchor" href="#基本的な関係図" aria-label="Permalink to &quot;基本的な関係図&quot;">​</a></h3>',15)),(a(),b(c,null,{default:t(()=>[n(s,{id:"mermaid-155",class:"mermaid",graph:"%20%20graph%20TB%0A%20%20%20%20%20%20Observable%5BObservable%3Cbr%2F%3E%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E4%BE%9B%E7%B5%A6%E5%85%83%5D%0A%20%20%20%20%20%20Observer%5BObserver%3Cbr%2F%3E%E3%83%87%E3%83%BC%E3%82%BF%E3%81%AE%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8A%E6%89%8B%5D%0A%20%20%20%20%20%20Subscription%5BSubscription%3Cbr%2F%3E%E8%B3%BC%E8%AA%AD%E3%81%AE%E5%88%B6%E5%BE%A1%E3%83%8F%E3%83%B3%E3%83%89%E3%83%AB%5D%0A%0A%20%20%20%20%20%20Observable%20--%3E%7Csubscribe%7C%20Subscription%0A%20%20%20%20%20%20Subscription%20--%3E%7C%E9%80%9A%E7%9F%A5%7C%20Observer%0A%20%20%20%20%20%20Observer%20--%3E%7Cnext%2Ferror%2Fcomplete%7C%20Process%5B%E3%83%87%E3%83%BC%E3%82%BF%E5%87%A6%E7%90%86%5D%0A%20%20%20%20%20%20Subscription%20--%3E%7Cunsubscribe%7C%20Cleanup%5B%E8%B3%BC%E8%AA%AD%E8%A7%A3%E9%99%A4%E3%83%BB%3Cbr%2F%3E%E3%83%AA%E3%82%BD%E3%83%BC%E3%82%B9%E8%A7%A3%E6%94%BE%5D%0A%0A%20%20%20%20%20%20style%20Observable%20fill%3A%23e1f5ff%2Ccolor%3A%23333%0A%20%20%20%20%20%20style%20Observer%20fill%3A%23fff4e1%2Ccolor%3A%23333%0A%20%20%20%20%20%20style%20Subscription%20fill%3A%23e8f5e9%2Ccolor%3A%23333%0A"})]),fallback:t(()=>[...e[0]||(e[0]=[d(" Loading... ",-1)])]),_:1})),e[2]||(e[2]=r('<h2 id="まとめ" tabindex="-1">まとめ <a class="header-anchor" href="#まとめ" aria-label="Permalink to &quot;まとめ&quot;">​</a></h2><p>RxJSの中核である「ストリーム」の概念は、非同期処理を扱う際の強力な武器です。Observableを使うことで、さまざまなデータソースを統一的に扱い、宣言的かつ柔軟にデータフローを記述できます。</p><h2 id="イベント処理との関係" tabindex="-1">イベント処理との関係 <a class="header-anchor" href="#イベント処理との関係" aria-label="Permalink to &quot;イベント処理との関係&quot;">​</a></h2><p>RxJSでは、DOMイベントも <code>fromEvent</code> を使ってストリームとして扱うことができます。<br> 従来のイベントリスナーとの違いを比較することで、ストリームの概念がより明確になります。</p><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>実際のコードを交えた従来のイベント処理とRxJSの比較は、<a href="/RxJS-with-TypeScript/guide/observables/events.html#従来のイベント処理とrxjsの比較">イベントのストリーム化</a> を参照してください。</p></div>',5))])}const S=i(h,[["render",u]]);export{B as __pageData,S as default};
