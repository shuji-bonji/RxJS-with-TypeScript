import{_ as e,c as a,o as s,a2 as i}from"./chunks/framework.BvXV5w7a.js";const b=JSON.parse('{"title":"RxJSとは何か？","description":"","frontmatter":{},"headers":[],"relativePath":"guide/basics/what-is-rxjs.md","filePath":"guide/basics/what-is-rxjs.md"}'),r={name:"guide/basics/what-is-rxjs.md"};function d(l,t,o,h,n,c){return s(),a("div",null,t[0]||(t[0]=[i(`<h1 id="rxjsとは何か" tabindex="-1">RxJSとは何か？ <a class="header-anchor" href="#rxjsとは何か" aria-label="Permalink to &quot;RxJSとは何か？&quot;">​</a></h1><h2 id="概要" tabindex="-1">概要 <a class="header-anchor" href="#概要" aria-label="Permalink to &quot;概要&quot;">​</a></h2><p>RxJS（Reactive Extensions for JavaScript）とは、「リアクティブプログラミング」を JavaScript で行うためのライブラリです。</p><blockquote><h3 id="リアクティブプログラミングとは" tabindex="-1">リアクティブプログラミングとは？ <a class="header-anchor" href="#リアクティブプログラミングとは" aria-label="Permalink to &quot;リアクティブプログラミングとは？&quot;">​</a></h3><p>リアクティブプログラミングは、データの変化に応じて自動的に更新されるプログラムの作成方法です。 イベント駆動型プログラミングの一種であり、特に非同期なデータストリームの扱いに焦点を当てています。 データの流れ（ストリーム）を中心に考え、その流れに対して反応（リアクション）する方式でプログラムを構築します。</p></blockquote><p>つまり、RxJSはイベントや非同期データの流れ（ストリーム）を、関数型スタイルで扱うためのライブラリです。Observableパターンを利用して、非同期データストリームを扱うための強力なツールを提供します。</p><blockquote><p>Observableとは、イベントや非同期データの流れ（ストリーム）を表現するRxJSの中核的な構成要素です。値が「流れてくる」源であり、購読（subscribe）によって値を受け取ることができます。Observableとは、時間の経過とともに値を発行する「データの流れ（ストリーム）」です。購読（subscribe）することで、その値を受け取ることができます。</p></blockquote><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>「ストリームってそもそも何？」という方は、<a href="/RxJS-with-TypeScript/guide/basics/what-is-a-stream.html">ストリームとは？</a> も参照してみてください。</p></div><h2 id="簡単な使用例" tabindex="-1">簡単な使用例 <a class="header-anchor" href="#簡単な使用例" aria-label="Permalink to &quot;簡単な使用例&quot;">​</a></h2><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { fromEvent } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;rxjs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fromEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">subscribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;クリックされました:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, event);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h2 id="rxjsの基本構成要素" tabindex="-1">RxJSの基本構成要素 <a class="header-anchor" href="#rxjsの基本構成要素" aria-label="Permalink to &quot;RxJSの基本構成要素&quot;">​</a></h2><p>RxJSを使いこなすには、以下の中核的な構成要素を理解することが重要です。</p><table tabindex="0"><thead><tr><th>構成要素</th><th>概要</th></tr></thead><tbody><tr><td><a href="./../observables/what-is-observable.html"><code>Observable</code></a></td><td>非同期または時間に沿って発生するデータを表すストリームの源です。</td></tr><tr><td><a href="./../observables/observable-lifecycle.html#observer"><code>Observer</code></a></td><td>Observableからデータを購読して受け取る側の存在です。</td></tr><tr><td><a href="./../observables/observable-lifecycle.html#subscription"><code>Subscription</code></a></td><td>Observableの購読と解除の管理を行います。</td></tr><tr><td><a href="./../operators/"><code>Operator</code></a></td><td>Observableを変換・合成・制御するための関数群です。</td></tr><tr><td><a href="./../subjects/what-is-subject.html"><code>Subject</code></a><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></td><td>ObservableとObserverの両方の性質を持つ中継器です。</td></tr><tr><td><a href="./../schedulers/async-control.html"><code>Scheduler</code></a><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></td><td>Observableの実行タイミングを制御する仕組みです。</td></tr></tbody></table><p>これらはそれぞれ独立した機能を持ちながらも連携して動作します。<br> たとえば、Observableが値を発行し、それをObserverが購読し、Operatorで変換し、Schedulerで制御する、といった形で、全体としてストリーム処理を構成します。</p><p>※ 各構成要素の詳細な使い方や例については、それぞれの専用章で個別に解説します。</p><h2 id="rxjsの利点" tabindex="-1">RxJSの利点 <a class="header-anchor" href="#rxjsの利点" aria-label="Permalink to &quot;RxJSの利点&quot;">​</a></h2><table tabindex="0"><thead><tr><th>利点</th><th>内容</th></tr></thead><tbody><tr><td>宣言的コード<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></td><td><code>map</code>, <code>filter</code> などで「何をしたいか」を記述し、forループなどの手続き的記述を避けられる</td></tr><tr><td>非同期処理の単純化</td><td><code>Promise</code> やコールバックのネストを避け、直感的な流れで書ける</td></tr><tr><td>エラー処理</td><td><code>.pipe(catchError(...))</code> などでストリーム中のエラーを統一的に処理可能</td></tr><tr><td>キャンセル可能</td><td><code>Subscription.unsubscribe()</code> によりストリームの中断が可能</td></tr><tr><td>多様なオペレーター</td><td><code>debounceTime</code>, <code>mergeMap</code>, <code>combineLatest</code> など多数の演算子で変換や合成が可能</td></tr></tbody></table><h2 id="ユースケース" tabindex="-1">ユースケース <a class="header-anchor" href="#ユースケース" aria-label="Permalink to &quot;ユースケース&quot;">​</a></h2><p>RxJSは以下のような状況で特に役立ちます。</p><table tabindex="0"><thead><tr><th>ユースケース</th><th>内容</th></tr></thead><tbody><tr><td>UIイベント処理</td><td>クリック、スクロール、入力などのユーザーインタラクション</td></tr><tr><td>HTTP要求</td><td>サーバーとの通信</td></tr><tr><td>WebSocketの処理</td><td>リアルタイムデータストリーム</td></tr><tr><td>状態管理</td><td>アプリケーションの状態を扱う（NgRx、Redux-Observable、またはカスタム状態管理）</td></tr></tbody></table><h2 id="まとめ" tabindex="-1">まとめ <a class="header-anchor" href="#まとめ" aria-label="Permalink to &quot;まとめ&quot;">​</a></h2><p>RxJSは、非同期およびイベントベースのプログラミングに対する強力なアプローチを提供します。Observableを中心としたデータストリームの考え方は、複雑な非同期処理を扱う際に特に役立ちます。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Subjectは、値を発行するObservableであると同時に、値を受け取るObserverとしても振る舞える特殊な存在です。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>Schedulerは、非同期処理の実行タイミングやコンテキストを制御するために使われ、デバッグやパフォーマンス管理にも役立ちます。 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><blockquote><ul><li>宣言的コード: 「どういう結果が欲しいのか」を素直に書くコード</li><li>手続き的コード: 「どういう計算を行っていけば欲しい結果が手に入るのか」を書くコード</li></ul></blockquote><a href="#fnref3" class="footnote-backref">↩︎</a></li></ol></section>`,23)]))}const k=e(r,[["render",d]]);export{b as __pageData,k as default};
