import{_ as t,c as o,o as a,a2 as r}from"./chunks/framework.D3KFGq5-.js";const h=JSON.parse('{"title":"Operadores de Utilidad","description":"Los operadores de utilidad son un grupo de operadores auxiliares en RxJS que se encargan de controlar efectos secundarios, procesamiento de retardo, gestión de suscripciones, etc.","frontmatter":{"description":"Los operadores de utilidad son un grupo de operadores auxiliares en RxJS que se encargan de controlar efectos secundarios, procesamiento de retardo, gestión de suscripciones, etc."},"headers":[],"relativePath":"es/guide/operators/utility/index.md","filePath":"es/guide/operators/utility/index.md","lastUpdated":1765383284000}'),d={name:"es/guide/operators/utility/index.md"};function i(s,e,c,n,l,p){return a(),o("div",null,[...e[0]||(e[0]=[r('<h1 id="operadores-de-utilidad" tabindex="-1">Operadores de Utilidad <a class="header-anchor" href="#operadores-de-utilidad" aria-label="Permalink to &quot;Operadores de Utilidad&quot;">​</a></h1><p>Los operadores de utilidad en RxJS son un grupo de operadores que se encargan del <strong>procesamiento auxiliar de streams (efectos secundarios, control de estado, soporte de UI, etc.)</strong> en lugar del propósito principal de conversión o filtrado de datos.</p><p>En esta página, los operadores se clasifican por propósito como se muestra a continuación, y se proporciona una lista para confirmar su uso básico. Para el uso detallado y ejemplos prácticos, consulte las páginas respectivas o <a href="./practical-use-cases">Casos de Uso Prácticos</a>.</p><h2 id="lista-de-operadores-por-proposito" tabindex="-1">Lista de Operadores (por Propósito) <a class="header-anchor" href="#lista-de-operadores-por-proposito" aria-label="Permalink to &quot;Lista de Operadores (por Propósito)&quot;">​</a></h2><h3 id="◾-efectos-secundarios-y-control-de-estado" tabindex="-1">◾ Efectos Secundarios y Control de Estado <a class="header-anchor" href="#◾-efectos-secundarios-y-control-de-estado" aria-label="Permalink to &quot;◾ Efectos Secundarios y Control de Estado&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Operador</th><th>Descripción</th><th>A menudo Combinado Con</th></tr></thead><tbody><tr><td><a href="./tap">tap</a></td><td>Ejecutar efectos secundarios sin cambiar valores (salida de log, actualizaciones de UI, etc.)</td><td><code>map</code>, <code>switchMap</code></td></tr><tr><td><a href="./finalize">finalize</a></td><td>Ejecutar procesamiento de limpieza cuando termina el stream</td><td><code>tap</code>, <code>catchError</code></td></tr></tbody></table><h3 id="◾-control-de-temporizacion-y-retardo" tabindex="-1">◾ Control de Temporización y Retardo <a class="header-anchor" href="#◾-control-de-temporizacion-y-retardo" aria-label="Permalink to &quot;◾ Control de Temporización y Retardo&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Operador</th><th>Descripción</th><th>A menudo Combinado Con</th></tr></thead><tbody><tr><td><a href="./delay">delay</a></td><td>Retrasar la emisión de cada valor por un tiempo especificado</td><td><code>tap</code>, <code>concatMap</code></td></tr><tr><td><a href="./timeout">timeout</a></td><td>Generar un error si la emisión excede cierto tiempo</td><td><code>catchError</code>, <code>retry</code></td></tr><tr><td><a href="./takeUntil">takeUntil</a></td><td>Finalizar suscripción cuando el Observable especificado notifica</td><td><code>interval</code>, <code>fromEvent</code></td></tr></tbody></table><h3 id="◾-valor-inicial-repeticion-conversion-a-array-etc" tabindex="-1">◾ Valor Inicial, Repetición, Conversión a Array, etc. <a class="header-anchor" href="#◾-valor-inicial-repeticion-conversion-a-array-etc" aria-label="Permalink to &quot;◾ Valor Inicial, Repetición, Conversión a Array, etc.&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Operador</th><th>Descripción</th><th>A menudo Combinado Con</th></tr></thead><tbody><tr><td><a href="./startWith">startWith</a></td><td>Emitir un valor inicial al principio del stream</td><td><code>scan</code>, <code>combineLatest</code></td></tr><tr><td><a href="./repeat">repeat</a></td><td>Resuscribirse al stream completo después de completarse</td><td><code>tap</code>, <code>delay</code></td></tr><tr><td><a href="./retry">retry</a></td><td>Reintentar en caso de error</td><td><code>catchError</code>, <code>switchMap</code></td></tr><tr><td><a href="./toArray">toArray</a></td><td>Emitir todos los valores en el stream como un solo array (al completarse)</td><td><code>concatMap</code>, <code>take</code></td></tr></tbody></table><h2 id="observaciones" tabindex="-1">Observaciones <a class="header-anchor" href="#observaciones" aria-label="Permalink to &quot;Observaciones&quot;">​</a></h2><ul><li>Diferencia entre <code>retry</code> y <code>repeat</code>: <ul><li><code>retry</code>: <strong>Reintentar en caso de error</strong></li><li><code>repeat</code>: <strong>Reintentar al completarse exitosamente</strong></li></ul></li><li><code>toArray</code> no emite un valor a menos que se complete, por lo que comúnmente se usa con <code>take()</code> y similares.</li></ul>',12)])])}const m=t(d,[["render",i]]);export{h as __pageData,m as default};
